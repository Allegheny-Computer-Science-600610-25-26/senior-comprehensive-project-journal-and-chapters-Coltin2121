# Introduction

My senior comprehensive project, GDBuddy, is a hardware-in-the-loop (HIL) runner designed for the Raspberry Pi. It operates through a Docker container that runs within GitHub Actions, enabling seamless integration with existing continuous integration (CI) workflows. In its current form, GDBuddy is used in the education sector. With an active GDBuddy runner assignments that are pushed to GitHub can be ran on a real Raspberry Pi. While the students software is running GDBuddy evaluates its behavior against predefined requirements and provides real-time feedback directly on GitHub. This workflow creates a consistent and efficient testing-feedback loop for both instructors and students, improving code reliability and learning outcomes.


## Motivation

The development of GDBuddy was influenced by the need to better understand and improve the user experience for both students and instructors using the tool. Experiences with GDBuddy revealed that many users benefited from its services but had limited understanding of its inner workings from a development standpoint. This motivated a deeper exploration into how the tool operates and how it could be refined to meet the needs of both students and educators. By examining GDBuddy from both a production and user perspective, this project aims to bridge the gap between usability, functionality, and educational effectiveness.

As far as functionality goes testing embedded code typically requires manual steps such as flashing firmware to a device, observing physical behavior and then collecting results. These manual processes slow down iteration can can introduce some human error. This is the reason that GDBuddy was created, a tool that bridges the gap between cloud based CI workflows and physical hardware in the loop automation. By integrating the Raspberry Pi as a runner for GitHub Actions, GDBuddy enables developers to automatically build, deploy, and test their code on the real embedded device. This ultimately brings great reproducibility and ease of use.

## Current State of the Art

In the current space there are a variety of HIL implementations available on GitHub. An example of this would be zephyr_twister_hil_testing repository, which demonstrates how to integrate real-hardware testing within GitHub Actions. This project provides an example where it compiles Zephyr's basic/blinky firmware in the cloud (using GitHub-hosted runners), then flashes it and runs it on a self hosted runner connected to the physical hardware. This repository also focuses on the Nordic nRF52840 Development Kit paired with an ESP32 modem.

This project is similar to GDBuddy in the sense that it is looking at HIL testing through GitHub actions. However there is a lot to contrast here. To start GDBuddy focuses on an entirely different embedded device, Raspberry Pi. Also the setup process is much more simple as there is only a docker container that can be setup and running in just a couple of steps. The opposing repository requires significant manual setup for both the runner hardware and firmware flashing scripts. In the context of education this could cause accessibility issues for some learners as well as instructors.

In summary while projects such as Golioth's zephyr_twister_hil_testing demonstrate technical feasibility of HIL testing within GitHub Actions, GDBuddy builds upon this concept by emphasizing accessibility, educational integration, and ease of deployment, making it better suited for the classroom environment. 

## Goals of the Project

The primary goal of GDBuddy is to enhance the accessibility and automation in hardware-in-the-loop testing for the Raspberry Pi platform. GDBuddy aims to achieve the following goals

1. Automated Hardware Testing
    Enables software to be automatically built, deployed, and tested on a Raspberry Pi through GitHub Actions.

2. Simplified Setup Process
    Provide a easy a to manage Docker-based environment that can be easily deployed by instructors with minimal specialized configuring.

3. Scalability and Reliability
    Ensure that GDBudddy can scale to multiple jobs while still maintaining consistent performance and accurate feedback. 

## Ethical Implications

This document requires that you discuss the ethical implications of your work -- no
matter how benign you consider the outcome of your project. As several major studies
of ethical issues in computer science assert: _no project is completely value-neutral_.

To assist you in elaborating on these issues, the following areas are topics you might
consider addressing. You do not need to address all of them.

* Information Privacy
* Information Accuracy (e.g. can contain reliability)
* Potential Misuse (e.g. computer crime, unintended consequences)
* Second- or Third-Party Risk (e.g. safety)
* Data Collection Issues (e.g. issues inherent in collecting data)
* Algorithmic or Data Bias
* Potential Power Difference / Social Imbalance / Issues in Equity

In addition, reflect on ways that the above harms can be or are mitigated by your work.
